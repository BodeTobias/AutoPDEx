<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>autopdex.models &mdash; AutoPDEx 1.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css?v=572af1d6" />
      <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=acfd50eb" />
      <link rel="stylesheet" type="text/css" href="../../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=1ed6394b"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="../../_static/dark_mode_js/default_light.js?v=c2e647ce"></script>
        <script src="../../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            AutoPDEx
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/quickstart.html">Quickstart to AutoPDEx</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">High level operations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../solver.html">Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../models.html">Models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Settings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../settings.html">Settings and static_settings</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../example_notebooks.html">Example notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examplary input files</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Lower level operations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../assembler.html">Assembler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../implicit_diff.html">Implicit_diff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spaces.html">Spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../solution_structures.html">Solution_structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../variational_schemes.html">Variational_schemes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Pre- and postprocessing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../geometry.html">Geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../seeder.html">Seeder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utility.html">Utility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plotter.html">Plotter</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">AutoPDEx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">autopdex.models</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for autopdex.models</h1><div class="highlight"><pre>
<span></span><span class="c1"># models.py</span>
<span class="c1"># Copyright (C) 2024 Tobias Bode</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Affero General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="c1"># GNU Affero General Public License for more details.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains premade jax-transformable partial differential equation (PDE) formulations, weak forms, user-defined elements, and time integration procedures.</span>

<span class="sd">The models-functions return callables with appropriate arguments for the use required in the other modules of AutoPDEx. These functions can then be passed e.g. to the solver via static_settings[&#39;model&#39;].</span>

<span class="sd">For instance, a typical weak form function has the following arguments:</span>
<span class="sd">  - x (jnp.ndarray): Spatial coordinates at the integration point.</span>
<span class="sd">  - ansatz (function): Ansatz function representing the field variable (e.g., displacement or temperature).</span>
<span class="sd">  - test_ansatz (function): Test ansatz function representing the virtual displacement or virtual temperature.</span>
<span class="sd">  - settings (dict): Settings for the computation.</span>
<span class="sd">  - static_settings (dict): Static settings for the computation.</span>
<span class="sd">  - int_point_number (int): Integration point number.</span>
<span class="sd">  - set: Number of domain.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>

<span class="kn">from</span> <span class="nn">autopdex</span> <span class="kn">import</span> <span class="n">solution_structures</span>



<span class="c1">### Linear equations</span>

<div class="viewcode-block" id="transport_equation">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.transport_equation.html#autopdex.models.transport_equation">[docs]</a>
<span class="k">def</span> <span class="nf">transport_equation</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Transport equation: du/dt + c * du/dx = 0</span>

<span class="sd">  Parameters:</span>
<span class="sd">    c (float): Transport coefficient.</span>

<span class="sd">  Returns:</span>
<span class="sd">    pde_fun (function): Function to compute the PDE residual.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">ansatz</span>
    <span class="n">u_derivative</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">u_x</span> <span class="o">=</span> <span class="n">u_derivative</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u_t</span> <span class="o">=</span> <span class="n">u_derivative</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u_t</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">u_x</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="poisson">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.poisson.html#autopdex.models.poisson">[docs]</a>
<span class="k">def</span> <span class="nf">poisson</span><span class="p">(</span><span class="n">coefficient_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">source_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Poisson equation in n dimensions: coefficient * Laplace(Theta) + source_term = 0</span>

<span class="sd">  Parameters:</span>
<span class="sd">    coefficient_fun (function): Function to compute the coefficient</span>
<span class="sd">    source_fun (function (dependend on the position jnp.ndarray x), optional): Function to compute the source term, defaults to None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    pde_fun (function): Function to compute the PDE residual.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">hessian</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">ansatz</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Coefficient</span>
    <span class="n">coefficient</span> <span class="o">=</span> <span class="n">coefficient_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">source_fun</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
      <span class="n">pde</span> <span class="o">=</span> <span class="n">coefficient</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">hessian</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pde</span> <span class="o">=</span> <span class="n">coefficient</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">hessian</span><span class="p">)</span> <span class="o">+</span> <span class="n">source_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pde</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="poisson_weak">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.poisson_weak.html#autopdex.models.poisson_weak">[docs]</a>
<span class="k">def</span> <span class="nf">poisson_weak</span><span class="p">(</span><span class="n">coefficient_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">source_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Poisson equation in n dimensions as weak form.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    coefficient_fun (function): Function to compute the coefficient of the laplacian, defaults to 1.</span>
<span class="sd">    source_fun (function (dependend on the position jnp.ndarray x), optional): Function to compute the source term, defaults to None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    pde_fun (function): Function to compute the weak form of the PDE.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Virtual temperature change and gradient</span>
    <span class="n">var_theta</span> <span class="o">=</span> <span class="n">test_ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">var_theta_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">test_ansatz</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Temperature gradient</span>
    <span class="n">theta_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Coefficient</span>
    <span class="n">coefficient</span> <span class="o">=</span> <span class="n">coefficient_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">source_fun</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
      <span class="n">pde</span> <span class="o">=</span> <span class="o">-</span><span class="n">coefficient</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">theta_grad</span><span class="p">,</span> <span class="n">var_theta_grad</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pde</span> <span class="o">=</span> <span class="o">-</span><span class="n">coefficient</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">theta_grad</span><span class="p">,</span> <span class="n">var_theta_grad</span><span class="p">)</span> <span class="o">+</span> <span class="n">source_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">var_theta</span>

    <span class="k">return</span> <span class="n">pde</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="poisson_fos">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.poisson_fos.html#autopdex.models.poisson_fos">[docs]</a>
<span class="k">def</span> <span class="nf">poisson_fos</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span> <span class="n">coefficient_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">source_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Poisson equation as set of first order models augmented by curl(v)=0</span>
<span class="sd">  </span>
<span class="sd">  First field of solution space has to be scalar function; remaining fields form the gradient, i.e.</span>
<span class="sd">  theta = lambda x: ansatz(x)[0]</span>
<span class="sd">  grad_theta = lambda x: ansatz(x)[1:]</span>
<span class="sd">  n_dim = 2 or 3</span>

<span class="sd">  Parameters:</span>
<span class="sd">    spacing (float): Spacing for the weights.</span>
<span class="sd">    coefficient_fun (function): Function to compute the coefficient of the laplacian, defaults to 1.</span>
<span class="sd">    source_fun (function, optional): Function to compute the source term, defaults to None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    pde_fun (function): Function to compute the first order PDE system residuals.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Coefficient</span>
    <span class="n">coefficient</span> <span class="o">=</span> <span class="n">coefficient_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

    <span class="c1"># Primary fields</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">grad_theta</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># v</span>
    <span class="n">grad_v</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">grad_theta</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Poisson equation</span>
    <span class="k">if</span> <span class="n">source_fun</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
      <span class="n">pde_1</span> <span class="o">=</span> <span class="n">coefficient</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">grad_v</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pde_1</span> <span class="o">=</span> <span class="n">coefficient</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">grad_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">source_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>

    <span class="c1"># Substituted derivatives</span>
    <span class="n">pde_2</span> <span class="o">=</span> <span class="n">grad_theta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">theta</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Additional constraint in order to make functional fully H1 coercive</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;This dimensionality is not supported by laplacian_fos&quot;</span>
    <span class="n">pde_3</span> <span class="o">=</span> <span class="n">curl_v</span>

    <span class="n">w1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">spacing</span>
    <span class="n">w3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">spacing</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">w1</span><span class="o">*</span><span class="n">pde_1</span><span class="p">,</span> <span class="n">w2</span><span class="o">*</span><span class="n">pde_2</span><span class="p">,</span> <span class="n">w3</span><span class="o">*</span><span class="n">pde_3</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="heat_equation">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.heat_equation.html#autopdex.models.heat_equation">[docs]</a>
<span class="k">def</span> <span class="nf">heat_equation</span><span class="p">(</span><span class="n">diffusivity_fun</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Space-time heat equation with thermal diffusivity alpha.</span>

<span class="sd">  Last dimension is the time dimension, remaining dimensions are spatial dimensions</span>

<span class="sd">  Parameters:</span>
<span class="sd">    diffusivity_fun (function): Function to compute the thermal diffusivity.</span>

<span class="sd">  Returns:</span>
<span class="sd">    heat_fun (function): Function to compute the PDE residual.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">heat_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">diffusivity_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">rate</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)(</span><span class="n">x</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># du / dt</span>
    <span class="n">spatial_derivatives</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">ansatz</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[:</span><span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">laplacian</span> <span class="o">=</span> <span class="n">spatial_derivatives</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># Laplace(u)</span>

    <span class="n">pde</span> <span class="o">=</span> <span class="n">rate</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">laplacian</span>
    <span class="k">return</span> <span class="n">pde</span>

  <span class="k">return</span> <span class="n">heat_fun</span></div>


<div class="viewcode-block" id="heat_equation_fos">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.heat_equation_fos.html#autopdex.models.heat_equation_fos">[docs]</a>
<span class="k">def</span> <span class="nf">heat_equation_fos</span><span class="p">(</span><span class="n">diffusivity_fun</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Space-time heat equation with thermal diffusivity alpha as a first order system with curl-augmentation for more than 2 spatial dimensions</span>
<span class="sd">  </span>
<span class="sd">  - supports n_dim = 2 to n_dim = 3, i.e. 1 to 3 spatial dimensions plus one time dimension</span>
<span class="sd">  - number of fiels: n_dim (1 temperature field, n_dim-1 spatial gradients)</span>
<span class="sd">  - last dimension is the time dimension, the remaining ones are spacial dimensions</span>

<span class="sd">  e.g. n_dim = 2:</span>
<span class="sd">  - first dimension is x-dimension, second dimension is time dimension</span>
<span class="sd">  - first field is temperature, second field is derivative of temperature with respect to x</span>

<span class="sd">  Parameters:</span>
<span class="sd">    diffusivity_fun (function): Function to compute the thermal diffusivity.</span>

<span class="sd">  Returns:</span>
<span class="sd">    heat_fun (function): Function to compute the PDE residual.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="k">def</span> <span class="nf">heat_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">diffusivity_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">temperature</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># u</span>
    <span class="n">derivative_field</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># v</span>
    <span class="n">derivatives</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">temperature</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># [du/dx, du/dt] (flat)</span>

    <span class="c1"># Heat equation with substituted spatial derivatives v</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">derivatives</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># du / dt</span>
    <span class="n">grad_v</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">derivative_field</span><span class="p">)(</span><span class="n">x</span><span class="p">)[:,:</span><span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">laplacian</span> <span class="o">=</span> <span class="n">grad_v</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># div(v)</span>
    <span class="n">pde_1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">rate</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">laplacian</span><span class="p">])</span>

    <span class="c1"># Substituted spatial derivatives: v - du / dx</span>
    <span class="n">pde_2</span> <span class="o">=</span> <span class="n">derivative_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">derivatives</span><span class="p">[:</span><span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Augmentation for stabilization</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;This dimensionality is not supported by heat_equation_fos&quot;</span>
    <span class="n">pde_3</span> <span class="o">=</span> <span class="n">curl_v</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pde_1</span><span class="p">,</span> <span class="n">pde_2</span><span class="p">,</span> <span class="n">pde_3</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">heat_fun</span></div>


<div class="viewcode-block" id="d_alembert">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.d_alembert.html#autopdex.models.d_alembert">[docs]</a>
<span class="k">def</span> <span class="nf">d_alembert</span><span class="p">(</span><span class="n">wave_number_fun</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Space-time d&#39;Alembert operator 1 temporal [-1] and (n-1) spatial [:n-1] dimension with wave number c.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    wave_number_fun (function): Function to compute the wave number.</span>

<span class="sd">  Returns:</span>
<span class="sd">    d_alembert_fun (function): Function to compute the PDE residual.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">d_alembert_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">wave_number_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">hessian</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">ansatz</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">hessian_diagonal</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">hessian_diagonal</span><span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">pde</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hessian_diagonal</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pde</span>
  
  <span class="k">return</span> <span class="n">d_alembert_fun</span></div>


<div class="viewcode-block" id="d_alembert_fos">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.d_alembert_fos.html#autopdex.models.d_alembert_fos">[docs]</a>
<span class="k">def</span> <span class="nf">d_alembert_fos</span><span class="p">(</span><span class="n">wave_number_fun</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs a first-order system for the space-time d&#39;Alembert operator with wave speed c.</span>

<span class="sd">  This function returns a PDE function representing the d&#39;Alembert operator for one temporal dimension </span>
<span class="sd">  and (n-1) spatial dimensions, with augmented conditions to ensure a fully H1 coercive functional.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    wave_number_fun (function): A function that computes the wave number (inverse of wave speed) given spatial coordinates.</span>
<span class="sd">    spacing (float): The spatial spacing parameter used to scale the augmented conditions.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the first-order system of PDEs for the d&#39;Alembert operator, which includes:</span>
<span class="sd">      - The primary d&#39;Alembert operator.</span>
<span class="sd">      - Substituted derivative fields.</span>
<span class="sd">      - Additional constraints for stabilization (curl conditions).</span>
<span class="sd">  </span>
<span class="sd">  Notes:</span>
<span class="sd">  - The last dimension of the input coordinates x is considered the time dimension; the remaining dimensions are spatial dimensions.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">d_alembert_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Initialization</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">wave_number_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">field</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">derivative_field</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    
    <span class="c1"># First pde: D&#39; Alembert operator</span>
    <span class="n">hessian</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">derivative_field</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">hessian_diagonal</span> <span class="o">=</span> <span class="n">hessian</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">hessian_diagonal</span><span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span> <span class="c1"># The other c is already in the other pde</span>
    <span class="n">pde_1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hessian_diagonal</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)])</span>

    <span class="c1"># Second pde: Gradient field</span>
    <span class="n">scaled_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">field</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">scaled_grad</span> <span class="o">=</span> <span class="n">scaled_grad</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">pde_2</span> <span class="o">=</span> <span class="n">derivative_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">scaled_grad</span>

    <span class="c1"># Additional constraint in order to make functional fully H1 coercive</span>
    <span class="c1"># grad_v = derivative_field(x)</span>
    <span class="n">grad_v</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">derivative_field</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
      <span class="n">curl_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">grad_v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">grad_v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;This dimensionality is not supported by laplacian_fos&quot;</span>
    <span class="n">pde_3</span> <span class="o">=</span> <span class="n">curl_v</span>

    <span class="n">w1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">spacing</span>
    <span class="n">w3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">spacing</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">w1</span><span class="o">*</span><span class="n">pde_1</span><span class="p">,</span> <span class="n">w2</span><span class="o">*</span><span class="n">pde_2</span><span class="p">,</span> <span class="n">w3</span><span class="o">*</span><span class="n">pde_3</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

  <span class="k">return</span> <span class="n">d_alembert_fun</span></div>


<div class="viewcode-block" id="linear_elasticity">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.linear_elasticity.html#autopdex.models.linear_elasticity">[docs]</a>
<span class="k">def</span> <span class="nf">linear_elasticity</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">,</span> <span class="n">poisson_ratio_fun</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the strong form of linear elasticity in Voigt notation, displacement based.</span>

<span class="sd">  This function supports 2D plain strain, 2D plain stress, and 3D elasticity problems.</span>

<span class="sd">  Parameters:</span>
<span class="sd">  youngs_mod_fun (function): Function to compute Young&#39;s modulus given spatial coordinates (and optional settings).</span>
<span class="sd">  poisson_ratio_fun (function): Function to compute Poisson&#39;s ratio given spatial coordinates (and optional settings).</span>
<span class="sd">  mode (str): Specifies the mode of the elasticity problem. It can be &#39;plain strain&#39;, &#39;plain stress&#39;, or &#39;3d&#39;.</span>
<span class="sd">  volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">  function: A function that evaluates the strong form PDE for linear elasticity.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain strain&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain stress&#39;</span><span class="p">:</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">mode</span><span class="se">\&#39;</span><span class="s1"> for linear elasticity not properly set.&#39;</span>

  <span class="k">def</span> <span class="nf">lin_el_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_stress</span><span class="p">(</span><span class="n">xf</span><span class="p">):</span>
      <span class="c1"># Kinematics</span>
      <span class="n">displacement</span> <span class="o">=</span> <span class="n">ansatz</span>
      <span class="n">displ_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)(</span><span class="n">xf</span><span class="p">)</span>
      <span class="n">strain</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">displ_grad</span> <span class="o">+</span> <span class="n">displ_grad</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">strain_voigt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">strain_voigt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">strain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

      <span class="c1"># Constiutive model</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">poisson_ratio_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

      <span class="k">match</span> <span class="n">mode</span><span class="p">:</span>
        <span class="k">case</span> <span class="s1">&#39;plain strain&#39;</span><span class="p">:</span>
          <span class="n">mu</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">))</span>
          <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span>
          <span class="n">c2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span>
          <span class="n">coeff</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">/</span> <span class="n">c1</span>
          <span class="n">material_tangent</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">c2</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c1</span><span class="p">]])</span>

        <span class="k">case</span> <span class="s1">&#39;plain stress&#39;</span><span class="p">:</span>
          <span class="n">coeff</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="n">material_tangent</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]])</span>

        <span class="k">case</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
          <span class="n">coeff</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">)</span>
          <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span>
          <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span><span class="p">)</span> <span class="o">/</span> <span class="n">c1</span>
          <span class="n">c3</span> <span class="o">=</span> <span class="n">nu</span> <span class="o">/</span> <span class="n">c1</span>
          <span class="n">c4</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>
          <span class="n">material_tangent</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">c3</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">c3</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c4</span><span class="p">]])</span>

      <span class="k">return</span> <span class="n">material_tangent</span> <span class="o">@</span> <span class="n">strain_voigt</span>
    <span class="c1"># stress_voigt = get_stress(x)</span>

    <span class="c1"># Internal forces</span>
    <span class="n">grad_stress</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">get_stress</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">div_stress</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                <span class="n">grad_stress</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">div_stress</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                                <span class="n">grad_stress</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                                <span class="n">grad_stress</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

    <span class="c1"># Balance equation</span>
    <span class="k">if</span> <span class="n">volume_load_fun</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">div_stress</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">div_stress</span> <span class="o">+</span> <span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lin_el_fun</span></div>


<div class="viewcode-block" id="linear_elasticity_weak">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.linear_elasticity_weak.html#autopdex.models.linear_elasticity_weak">[docs]</a>
<span class="k">def</span> <span class="nf">linear_elasticity_weak</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">,</span> <span class="n">poisson_ratio_fun</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">  Constructs the weak form of linear elasticity in Voigt notation, displacement based.</span>

<span class="sd">  This function supports 2D plain strain, 2D plain stress, and 3D elasticity problems.</span>

<span class="sd">  Parameters:</span>
<span class="sd">  youngs_mod_fun (function): Function to compute Young&#39;s modulus given spatial coordinates (and optional settings).</span>
<span class="sd">  poisson_ratio_fun (function): Function to compute Poisson&#39;s ratio given spatial coordinates (and optional settings).</span>
<span class="sd">  mode (str): Specifies the mode of the elasticity problem. It can be &#39;plain strain&#39;, &#39;plain stress&#39;, or &#39;3d&#39;.</span>
<span class="sd">  volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">  function: A function that evaluates the weak form PDE for linear elasticity.</span>

<span class="sd">  Todo: </span>
<span class="sd">  - anisotropy modes</span>
<span class="sd">  - support for dynamic problems</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain strain&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain stress&#39;</span><span class="p">:</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">mode</span><span class="se">\&#39;</span><span class="s1"> for linear elasticity not properly set.&#39;</span>

  <span class="k">def</span> <span class="nf">lin_el_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_stress</span><span class="p">(</span><span class="n">xf</span><span class="p">):</span>
      <span class="c1"># Kinematics</span>
      <span class="n">displacement</span> <span class="o">=</span> <span class="n">ansatz</span>
      <span class="n">displ_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)(</span><span class="n">xf</span><span class="p">)</span>
      <span class="n">strain</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">displ_grad</span> <span class="o">+</span> <span class="n">displ_grad</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
      <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">strain_voigt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">strain_voigt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">strain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

      <span class="c1"># Constiutive model</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">poisson_ratio_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
      <span class="k">match</span> <span class="n">mode</span><span class="p">:</span>
        <span class="k">case</span> <span class="s1">&#39;plain strain&#39;</span><span class="p">:</span>
          <span class="n">mu</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">))</span>
          <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span>
          <span class="n">c2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span>
          <span class="n">coeff</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">/</span> <span class="n">c1</span>
          <span class="n">material_tangent</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">c2</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c1</span><span class="p">]])</span>

        <span class="k">case</span> <span class="s1">&#39;plain stress&#39;</span><span class="p">:</span>
          <span class="n">coeff</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="n">material_tangent</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">nu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]])</span>

        <span class="k">case</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
          <span class="n">coeff</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">)</span>
          <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span>
          <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu</span><span class="p">)</span> <span class="o">/</span> <span class="n">c1</span>
          <span class="n">c3</span> <span class="o">=</span> <span class="n">nu</span> <span class="o">/</span> <span class="n">c1</span>
          <span class="n">c4</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>
          <span class="n">material_tangent</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">c3</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="n">c3</span><span class="p">,</span> <span class="n">c3</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c4</span><span class="p">]])</span>

      <span class="k">return</span> <span class="n">material_tangent</span> <span class="o">@</span> <span class="n">strain_voigt</span>
    <span class="n">stress_voigt</span> <span class="o">=</span> <span class="n">get_stress</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Test function</span>
    <span class="n">virtual_disp</span> <span class="o">=</span> <span class="n">test_ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">virtual_disp_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">test_ansatz</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">virtual_strain</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">virtual_disp_grad</span> <span class="o">+</span> <span class="n">virtual_disp_grad</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">virtual_strain_voigt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">virtual_strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">virtual_strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">virtual_strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">virtual_strain_voigt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">virtual_strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">virtual_strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">virtual_strain</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">virtual_strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">virtual_strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">virtual_strain</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

    <span class="c1"># Balance equation</span>
    <span class="k">if</span> <span class="n">volume_load_fun</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stress_voigt</span><span class="p">,</span> <span class="n">virtual_strain_voigt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stress_voigt</span><span class="p">,</span> <span class="n">virtual_strain_voigt</span><span class="p">)</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">virtual_disp</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lin_el_fun</span></div>


<div class="viewcode-block" id="linear_elasticity_fos">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.linear_elasticity_fos.html#autopdex.models.linear_elasticity_fos">[docs]</a>
<span class="k">def</span> <span class="nf">linear_elasticity_fos</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">,</span> <span class="n">poisson_ratio_fun</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the first order system (FOS) of linear elasticity in Voigt notation, displacement based.</span>

<span class="sd">  This function supports 2D plain strain and 3D elasticity problems. The formulation is based on the first order </span>
<span class="sd">  system described in https://doi.org/10.1137/S0036142902418357 with additional asymmetry penalization.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    youngs_mod_fun (function): Function to compute Young&#39;s modulus given spatial coordinates (and optional settings).</span>
<span class="sd">    poisson_ratio_fun (function): Function to compute Poisson&#39;s ratio given spatial coordinates (and optional settings).</span>
<span class="sd">    mode (str): Specifies the mode of the elasticity problem. It can be &#39;plain strain&#39; or &#39;3d&#39;.</span>
<span class="sd">    spacing (float): The spatial spacing parameter used to scale the augmented conditions.</span>
<span class="sd">    volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the first order system of PDEs for linear elasticity.</span>

<span class="sd">  The returned function computes the following:</span>
<span class="sd">    - The kinematic strain based on the displacement gradient.</span>
<span class="sd">    - The constitutive relation using the specified Young&#39;s modulus and Poisson&#39;s ratio.</span>
<span class="sd">    - The internal force balance equation, optionally including volume loads.</span>
<span class="sd">    - Weak enforcement of symmetry of the Cauchy stress tensor.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - In 2D, the number of fields is 2 (displacement) + 4 (stress) = 6.</span>
<span class="sd">    - In 3D, the number of fields is 3 (displacement) + 9 (stress) = 12.</span>
<span class="sd">    - This function only supports &#39;plain strain&#39; and &#39;3d&#39; modes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain strain&#39;</span><span class="p">:</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">mode</span><span class="se">\&#39;</span><span class="s1"> for linear elasticity not properly set.&#39;</span>

  <span class="k">def</span> <span class="nf">lin_el_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Primary fields</span>
    <span class="n">displacement</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[:</span><span class="n">n_dim</span><span class="p">]</span>
    <span class="n">stress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="n">n_dim</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">))</span>

    <span class="c1"># Kinematics</span>
    <span class="n">displ_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">displacement</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">strain</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">displ_grad</span> <span class="o">+</span> <span class="n">displ_grad</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

    <span class="c1"># Constiutive model</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">poisson_ratio_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">))</span> <span class="c1"># Shear modulus</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span><span class="p">))</span><span class="c1"># First Lame constant</span>

    <span class="c1"># Complience tensor times stress</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">stress</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">A_sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">-</span> <span class="p">(</span><span class="n">lam</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_dim</span> <span class="o">*</span> <span class="n">lam</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span><span class="p">))</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n_dim</span><span class="p">))</span>

    <span class="c1"># Second pde: constitutive model</span>
    <span class="n">pde_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_sigma</span> <span class="o">-</span> <span class="n">strain</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Internal forces</span>
    <span class="n">grad_stress</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">stress</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">div_stress</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">div_stress</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                                <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                                <span class="n">grad_stress</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad_stress</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>

    <span class="c1"># First pde: Balance equation</span>
    <span class="k">if</span> <span class="n">volume_load_fun</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">pde_1</span> <span class="o">=</span> <span class="n">div_stress</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pde_1</span> <span class="o">=</span> <span class="n">div_stress</span> <span class="o">+</span> <span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="c1"># Weak enforcement of symmetry of Cauchy stress</span>
    <span class="n">pde_3</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">stress</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">stress</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Return first order system</span>
    <span class="n">w_1</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">w_2</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">w_3</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">/</span> <span class="n">mu</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">w_1</span><span class="o">*</span><span class="n">pde_1</span><span class="p">,</span> <span class="n">w_2</span><span class="o">*</span><span class="n">pde_2</span><span class="p">,</span> <span class="n">w_3</span><span class="o">*</span><span class="n">pde_3</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  
  <span class="c1"># Return function for evaluating first order system with arguments x and ansatz</span>
  <span class="k">return</span> <span class="n">lin_el_fun</span></div>


<div class="viewcode-block" id="neumann_weak">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.neumann_weak.html#autopdex.models.neumann_weak">[docs]</a>
<span class="k">def</span> <span class="nf">neumann_weak</span><span class="p">(</span><span class="n">neumann_fun</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the weak form of Neumann boundary conditions for the virtual work of surface tractions or heat inflow.</span>

<span class="sd">  This function can be used to impose Neumann boundary conditions in the weak form of problems such as linear </span>
<span class="sd">  momentum balance or heat conduction.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    neumann_fun (callable): A function that computes the Neumann boundary condition (e.g., surface tractions or heat inflow)</span>
<span class="sd">        given spatial coordinates. This function can optionally take the settings as an additional argument.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function</span>
<span class="sd">        A function that evaluates the weak form of the Neumann boundary condition.</span>

<span class="sd">  The returned function computes the virtual work of the Neumann boundary condition, which is the dot product of </span>
<span class="sd">  the virtual displacement (or temperature) and the Neumann boundary condition (e.g., surface tractions or heat inflow).</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Test function</span>
    <span class="n">virtual_disp</span> <span class="o">=</span> <span class="n">test_ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Tractions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">neumann_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">tractions</span> <span class="o">=</span> <span class="n">neumann_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">tractions</span> <span class="o">=</span> <span class="n">neumann_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

    <span class="c1"># Virtual work</span>
    <span class="k">return</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">virtual_disp</span><span class="p">,</span> <span class="n">tractions</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">fun</span></div>



<span class="c1">### Nonlinear equations</span>

<div class="viewcode-block" id="burgers_equation_inviscid">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.burgers_equation_inviscid.html#autopdex.models.burgers_equation_inviscid">[docs]</a>
<span class="k">def</span> <span class="nf">burgers_equation_inviscid</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the inviscid Burgers&#39; equation: du/dt + u * du/dx = 0.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    None</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the inviscid Burgers&#39; equation.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - first dimension: x</span>
<span class="sd">    - second dimension: t</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">u_x</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u_t</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u_t</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">u_x</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="hyperelastic_steady_state_fos">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.hyperelastic_steady_state_fos.html#autopdex.models.hyperelastic_steady_state_fos">[docs]</a>
<span class="k">def</span> <span class="nf">hyperelastic_steady_state_fos</span><span class="p">(</span><span class="n">strain_energy_fun</span><span class="p">,</span> <span class="n">youngs_mod_fun</span><span class="p">,</span> <span class="n">poisson_ratio_fun</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs a first-order PDE system for given strain energy function</span>

<span class="sd">  This function is based on equation (28) in https://doi.org/10.1002/nme.5951 and returns a function </span>
<span class="sd">  representing the first-order PDE system for steady-state hyperelasticity.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    strain_energy_fun (function): Function that returns the strain energy given the deformation gradient and Lame parameters.</span>
<span class="sd">    youngs_mod_fun (function): Function to compute Young&#39;s modulus given spatial coordinates.</span>
<span class="sd">    poisson_ratio_fun (function): Function to compute Poisson&#39;s ratio given spatial coordinates.</span>
<span class="sd">    mode (str): Specifies the mode of the elasticity problem. It can be &#39;plain strain&#39; or &#39;3d&#39;.</span>
<span class="sd">    spacing (float): The spatial spacing parameter used to scale the augmented conditions.</span>
<span class="sd">    volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the first-order PDE system for hyperelasticity.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The volume load function, if provided, must be volume-specific.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Initialization</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">poisson_ratio_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

    <span class="c1"># Lame parameters</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span><span class="p">))</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">))</span>

    <span class="c1"># Ansatz</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[:</span><span class="n">n_dim</span><span class="p">]</span> <span class="c1"># Displacement</span>
    <span class="n">P</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="n">n_dim</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">))</span> <span class="c1"># 1. Piola-Kirchoff stress</span>

    <span class="c1"># Linear momentum balance</span>
    <span class="n">Grad_P</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">P</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Div_P</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Grad_P</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># First pde: Balance equation</span>
    <span class="k">if</span> <span class="n">volume_load_fun</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">pde_1</span> <span class="o">=</span> <span class="n">Div_P</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">pde_1</span> <span class="o">=</span> <span class="n">Div_P</span> <span class="o">+</span> <span class="n">b</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain strain&#39;</span><span class="p">:</span>
      <span class="c1"># Deformation gradient</span>
      <span class="n">H</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">F</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]),</span>
                       <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]),</span>
                       <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])])</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      
      <span class="c1"># First Piola-Kirchhoff stress</span>
      <span class="n">dpsi_dF</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">neo_hooke</span><span class="p">)(</span><span class="n">F</span><span class="p">,</span> <span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
      <span class="n">dpsi_dF_FT</span> <span class="o">=</span> <span class="p">(</span><span class="n">dpsi_dF</span> <span class="o">@</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">F</span><span class="p">))[:</span><span class="n">n_dim</span><span class="p">,:</span><span class="n">n_dim</span><span class="p">]</span>
      <span class="n">PFT</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)[:</span><span class="n">n_dim</span><span class="p">,:</span><span class="n">n_dim</span><span class="p">]</span> <span class="o">@</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">F</span><span class="p">[:</span><span class="n">n_dim</span><span class="p">,:</span><span class="n">n_dim</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
      <span class="c1"># Deformation gradient</span>
      <span class="n">F</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>


      <span class="c1"># First Piola-Kirchhoff stress</span>
      <span class="n">dpsi_dF</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">strain_energy_fun</span><span class="p">)(</span><span class="n">F</span><span class="p">,</span> <span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
      <span class="n">dpsi_dF_FT</span> <span class="o">=</span> <span class="n">dpsi_dF</span> <span class="o">@</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
      <span class="n">PFT</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">@</span> <span class="n">F</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Hyperelastic model supports only </span><span class="se">\&#39;</span><span class="s1">plain strain</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">3d</span><span class="se">\&#39;</span><span class="s1"> modes.&#39;</span>

    <span class="c1"># Constitutive law</span>
    <span class="n">pde_2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">PFT</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">PFT</span><span class="p">))</span> <span class="o">-</span> <span class="n">dpsi_dF_FT</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Enforce symmetry of P \cdot F^T</span>
    <span class="n">PFT_asym</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">PFT</span> <span class="o">-</span> <span class="n">PFT</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    <span class="n">pde_3</span> <span class="o">=</span> <span class="n">PFT_asym</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Weightings</span>
    <span class="n">w_1</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">w_2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">mu</span>
    <span class="n">w_3</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">/</span> <span class="n">mu</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">w_1</span> <span class="o">*</span> <span class="n">pde_1</span><span class="p">,</span> <span class="n">w_2</span> <span class="o">*</span> <span class="n">pde_2</span><span class="p">,</span> <span class="n">w_3</span> <span class="o">*</span> <span class="n">pde_3</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="hyperelastic_steady_state_weak">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.hyperelastic_steady_state_weak.html#autopdex.models.hyperelastic_steady_state_weak">[docs]</a>
<span class="k">def</span> <span class="nf">hyperelastic_steady_state_weak</span><span class="p">(</span><span class="n">strain_energy_fun</span><span class="p">,</span> <span class="n">youngs_mod_fun</span><span class="p">,</span> <span class="n">poisson_ratio_fun</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the weak form of hyperelasticity for given strain energy function</span>

<span class="sd">  This function returns a function representing the weak form PDE system for steady-state hyperelasticity.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    strain_energy_fun (function): Function that returns the strain energy given the deformation gradient and Lame parameters.</span>
<span class="sd">    youngs_mod_fun (function): Function to compute Young&#39;s modulus given spatial coordinates.</span>
<span class="sd">    poisson_ratio_fun (function): Function to compute Poisson&#39;s ratio given spatial coordinates.</span>
<span class="sd">    mode (str): Specifies the mode of the elasticity problem. It can be &#39;plain strain&#39; or &#39;3d&#39;.</span>
<span class="sd">    volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the weak form PDE system for hyperelasticity.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The volume load function, if provided, must be volume-specific.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Initialization</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">poisson_ratio_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">nu</span> <span class="o">=</span> <span class="n">poisson_ratio_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">youngs_mod_fun</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">Em</span> <span class="o">=</span> <span class="n">youngs_mod_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

    <span class="c1"># Lame parameters</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">*</span> <span class="n">nu</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nu</span><span class="p">))</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">Em</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nu</span><span class="p">))</span>

    <span class="c1"># (Virtual) displacement</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">ansatz</span>
    <span class="n">virt_u</span> <span class="o">=</span> <span class="n">test_ansatz</span>

    <span class="c1"># Deformation gradient</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plain strain&#39;</span><span class="p">:</span>
      <span class="n">H</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">F</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">],</span>
                       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>     <span class="mf">0.</span><span class="p">,</span>     <span class="mf">0.</span><span class="p">]])</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      
      <span class="n">virt_H</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">virt_u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">virt_F</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">virt_H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">virt_H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="mf">0.</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">virt_H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">virt_H</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="mf">0.</span><span class="p">],</span>
                            <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>          <span class="mf">0.</span><span class="p">,</span>           <span class="mf">0.</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
      <span class="n">F</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      <span class="n">virt_F</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">virt_u</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Hyperelastic model supports only </span><span class="se">\&#39;</span><span class="s1">plain strain</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">3d</span><span class="se">\&#39;</span><span class="s1"> modes.&#39;</span>

    <span class="c1"># First Piola-Kirchhoff stress</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">strain_energy_fun</span><span class="p">)(</span><span class="n">F</span><span class="p">,</span> <span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>

    <span class="c1"># Virtual work of internal forces</span>
    <span class="n">PI_int</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij, ij -&gt; &#39;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">virt_F</span><span class="p">)</span>
    <span class="c1"># PI_int = jnp.trace(P @ virt_F.transpose())</span>

    <span class="k">if</span> <span class="n">volume_load_fun</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">PI_int</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Add virtual work of volume forces</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">PI_ext</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">virt_u</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">PI_int</span> <span class="o">-</span> <span class="n">PI_ext</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="navier_stokes_incompressible_steady">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.navier_stokes_incompressible_steady.html#autopdex.models.navier_stokes_incompressible_steady">[docs]</a>
<span class="k">def</span> <span class="nf">navier_stokes_incompressible_steady</span><span class="p">(</span><span class="n">dynamic_viscosity</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">incompressible_weighting</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the steady-state incompressible Navier-Stokes equations.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    dynamic_viscosity (float): Dynamic viscosity of the fluid.</span>
<span class="sd">    density (float, optional): Density of the fluid. Default is 1.0.</span>
<span class="sd">    incompressible_weighting (float, optional): Weighting factor for the incompressibility constraint. Default is 1.0.</span>
<span class="sd">    volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the steady-state incompressible Navier-Stokes equations.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The first equation is the constraint of a divergence-free flow field.</span>
<span class="sd">    - The remaining equations are the linear momentum balance.</span>
<span class="sd">    - The first field in the ansatz function is the pressure field, and the remaining fields are the velocity components.</span>
<span class="sd">    - The density and viscosity are assumed to be constant.</span>
<span class="sd">    - The volume load function, if provided, must be volume-specific.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">pressure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># p</span>
    <span class="n">velocity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># v</span>

    <span class="n">grad_p</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">pressure</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">grad_v</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">velocity</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">laplace_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">velocity</span><span class="p">))(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Incompressible flow: div(v) = 0</span>
    <span class="n">pde_1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">grad_v</span><span class="p">)])</span>

    <span class="c1"># Linear momentum balance</span>
    <span class="k">if</span> <span class="n">volume_load_fun</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
      <span class="n">pde_2</span> <span class="o">=</span> <span class="n">grad_v</span> <span class="o">@</span> <span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_p</span> <span class="o">-</span> <span class="p">(</span><span class="n">dynamic_viscosity</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">laplace_v</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pde_2</span> <span class="o">=</span> <span class="n">grad_v</span> <span class="o">@</span> <span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_p</span> <span class="o">-</span> <span class="p">(</span><span class="n">dynamic_viscosity</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">laplace_v</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">incompressible_weighting</span> <span class="o">*</span> <span class="n">pde_1</span><span class="p">,</span> <span class="n">pde_2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>


<div class="viewcode-block" id="navier_stokes_incompressible">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.navier_stokes_incompressible.html#autopdex.models.navier_stokes_incompressible">[docs]</a>
<span class="k">def</span> <span class="nf">navier_stokes_incompressible</span><span class="p">(</span><span class="n">dynamic_viscosity</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">incompressible_weighting</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">volume_load_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs the transient incompressible Navier-Stokes equations.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    dynamic_viscosity (float): Dynamic viscosity of the fluid.</span>
<span class="sd">    density (float, optional): Density of the fluid. Default is 1.0.</span>
<span class="sd">    incompressible_weighting (float, optional): Weighting factor for the incompressibility constraint. Default is 1.0.</span>
<span class="sd">    volume_load_fun (function, optional): Function to compute volume load given spatial coordinates. Default is None.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function: A function that evaluates the transient incompressible Navier-Stokes equations.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The first equation is the constraint of a divergence-free flow field.</span>
<span class="sd">    - The remaining equations are the linear momentum balance.</span>
<span class="sd">    - The first field in the ansatz function is the pressure field, and the remaining fields are the velocity components.</span>
<span class="sd">    - The density and viscosity are assumed to be constant.</span>
<span class="sd">    - The volume load function, if provided, must be volume-specific.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">pde_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Number of spatial dimensions</span>
    <span class="n">n_sdim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">pressure</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># p</span>
    <span class="n">velocity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># v</span>

    <span class="n">grad_p</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">pressure</span><span class="p">)(</span><span class="n">x</span><span class="p">)[:</span><span class="n">n_sdim</span><span class="p">]</span>
    <span class="n">grad_v</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">velocity</span><span class="p">)(</span><span class="n">x</span><span class="p">)[:,:</span><span class="n">n_sdim</span><span class="p">]</span>
    <span class="n">dvdt</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">velocity</span><span class="p">)(</span><span class="n">x</span><span class="p">)[:,</span><span class="n">n_sdim</span><span class="p">]</span>
    <span class="n">laplace_v</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">velocity</span><span class="p">))(</span><span class="n">x</span><span class="p">)[:,:,:</span><span class="n">n_sdim</span><span class="p">],</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Incompressible flow: div(v) = 0</span>
    <span class="n">pde_1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">grad_v</span><span class="p">)])</span>

    <span class="c1"># Linear momentum balance</span>
    <span class="k">if</span> <span class="n">volume_load_fun</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
      <span class="n">pde_2</span> <span class="o">=</span> <span class="n">dvdt</span> <span class="o">+</span> <span class="n">grad_v</span> <span class="o">@</span> <span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_p</span> <span class="o">-</span> <span class="p">(</span><span class="n">dynamic_viscosity</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">laplace_v</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">pde_2</span> <span class="o">=</span> <span class="n">dvdt</span> <span class="o">+</span> <span class="n">grad_v</span> <span class="o">@</span> <span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_p</span> <span class="o">-</span> <span class="p">(</span><span class="n">dynamic_viscosity</span> <span class="o">/</span> <span class="n">density</span><span class="p">)</span> <span class="o">*</span> <span class="n">laplace_v</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">velocity</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">volume_load_fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">incompressible_weighting</span> <span class="o">*</span> <span class="n">pde_1</span><span class="p">,</span> <span class="n">pde_2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">pde_fun</span></div>



<span class="c1">### Strain energy functions</span>

<div class="viewcode-block" id="neo_hooke">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.neo_hooke.html#autopdex.models.neo_hooke">[docs]</a>
<span class="k">def</span> <span class="nf">neo_hooke</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Computes the strain energy for a neo-Hookean material model of Ciarlet type given the deformation gradient.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    F (jnp.ndarray): Deformation gradient tensor.</span>
<span class="sd">    param (tuple): Lame parameters (lambda, mu).</span>

<span class="sd">  Returns:</span>
<span class="sd">    float: Strain energy value for the given deformation gradient.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The strain energy function is based on the Ciarlet type neo-Hookean model.</span>
<span class="sd">    - This model is suitable for large deformation analysis in hyperelastic materials.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span> <span class="o">=</span> <span class="n">param</span>

  <span class="c1"># Right Cauchy-Green tensor</span>
  <span class="n">tr_C</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij, ij&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
  <span class="n">J</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
  <span class="n">ln_J</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

  <span class="c1"># Neo-Hookean strain energy function of Ciarlet type</span>
  <span class="n">psi</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tr_C</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">ln_J</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">lam</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">ln_J</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">psi</span></div>


<div class="viewcode-block" id="linear_elastic_strain_energy">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.linear_elastic_strain_energy.html#autopdex.models.linear_elastic_strain_energy">[docs]</a>
<span class="k">def</span> <span class="nf">linear_elastic_strain_energy</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Computes the strain energy for a linear elastic material for small deformations.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    F (jnp.ndarray): Deformation gradient tensor.</span>
<span class="sd">    param (tuple): Lame parameters (lambda, mu).</span>

<span class="sd">  Returns:</span>
<span class="sd">    float: Strain energy value for the given deformation gradient.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span> <span class="o">=</span> <span class="n">param</span>

  <span class="c1"># Right Cauchy-Green tensor</span>
  <span class="n">disp_grad</span> <span class="o">=</span> <span class="n">F</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">strain</span> <span class="o">=</span> <span class="p">(</span><span class="n">disp_grad</span> <span class="o">+</span> <span class="n">disp_grad</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">lam</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">strain</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">strain</span> <span class="o">@</span> <span class="n">strain</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>



<span class="c1">### User potentials/elements</span>
<div class="viewcode-block" id="isoparametric_domain_integrate_potential">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.isoparametric_domain_integrate_potential.html#autopdex.models.isoparametric_domain_integrate_potential">[docs]</a>
<span class="k">def</span> <span class="nf">isoparametric_domain_integrate_potential</span><span class="p">(</span><span class="n">integrand_fun</span><span class="p">,</span> <span class="n">ansatz_fun</span><span class="p">,</span> <span class="n">ref_int_coor</span><span class="p">,</span> <span class="n">ref_int_weights</span><span class="p">,</span> <span class="n">initial_config</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs a local integrand fun for integration of functions in the reference configuration of isoparametric elements.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    integrand_fun (callable): Function that evaluates the integrand given the integration point, trial ansatz, settings, static settings, and element number.</span>
<span class="sd">    ansatz_fun (callable): Function that constructs the ansatz (trial and test) functions.</span>
<span class="sd">    ref_int_coor (jnp.ndarray): Reference integration coordinates for the isoparametric element.</span>
<span class="sd">    ref_int_weights (jnp.ndarray): Reference integration weights for the isoparametric element.</span>
<span class="sd">    initial_config (bool, optional): If True, use the initial configuration for isoparametric mapping. Default is True.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function</span>
<span class="sd">        A function that evaluates the integrand for the isoparametric element.</span>

<span class="sd">  The returned function has the following parameters:</span>
<span class="sd">    - fI (jnp.ndarray): Element nodal values.</span>
<span class="sd">    - xI (jnp.ndarray): Element nodal coordinates.</span>
<span class="sd">    - elem_number (int): Element number.</span>
<span class="sd">    - settings (dict): Settings for the computation.</span>
<span class="sd">    - static_settings (dict): Static settings for the computation.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">user_element</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">elem_number</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">n_dofs</span> <span class="o">=</span> <span class="n">fI</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">xI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># One Gau point contribution</span>
    <span class="k">def</span> <span class="nf">functional</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">w_int</span><span class="p">):</span>

      <span class="k">def</span> <span class="nf">integrated_weak_form</span><span class="p">(</span><span class="n">trial_fI</span><span class="p">):</span>
        <span class="c1"># Define trial and test function ansatz</span>
        <span class="n">trial_ansatz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">trial_fI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>

        <span class="c1"># Evaluate functional</span>
        <span class="n">discrete_functional_fun</span> <span class="o">=</span> <span class="n">integrand_fun</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">trial_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">elem_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>

        <span class="c1"># Use ansatz for isoparametric mapping and compute determinant of Jacobian</span>
        <span class="k">if</span> <span class="n">initial_config</span><span class="p">:</span>
          <span class="n">mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Take first n_dim fields as displacements</span>
          <span class="n">uI</span> <span class="o">=</span> <span class="n">fI</span><span class="p">[:,</span> <span class="p">:</span><span class="n">xI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
          <span class="n">mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span> <span class="o">+</span> <span class="n">uI</span><span class="p">,</span> <span class="n">xI</span> <span class="o">+</span> <span class="n">uI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">overwrite_diff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">mapping</span><span class="p">)(</span><span class="n">x_int</span><span class="p">)</span>
        <span class="n">det_jacobian</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">w_int</span> <span class="o">*</span> <span class="n">det_jacobian</span> <span class="o">*</span> <span class="n">discrete_functional_fun</span>

      <span class="c1"># Residual</span>
      <span class="k">return</span> <span class="n">integrated_weak_form</span><span class="p">(</span><span class="n">fI</span><span class="p">)</span>

    <span class="c1"># Sum over Gau points</span>
    <span class="n">functional_contrib</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">functional</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)(</span><span class="n">ref_int_coor</span><span class="p">,</span> <span class="n">ref_int_weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">functional_contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">user_element</span></div>


<div class="viewcode-block" id="isoparametric_domain_element_galerkin">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.isoparametric_domain_element_galerkin.html#autopdex.models.isoparametric_domain_element_galerkin">[docs]</a>
<span class="k">def</span> <span class="nf">isoparametric_domain_element_galerkin</span><span class="p">(</span><span class="n">weak_form_fun</span><span class="p">,</span> <span class="n">ansatz_fun</span><span class="p">,</span> <span class="n">ref_int_coor</span><span class="p">,</span> <span class="n">ref_int_weights</span><span class="p">,</span> <span class="n">initial_config</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs an isoparametric domain element for Galerkin methods using a given weak form function.</span>

<span class="sd">  This function returns a user element function that evaluates the residual and tangent matrix for an isoparametric </span>
<span class="sd">  element based on the provided weak form and ansatz functions.</span>
<span class="sd">  The function can e.g. be used in combination with the weak_form_fun hyperelastic_steady_state_weak.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    weak_form_fun (callable): Function that evaluates the weak form given the integration point, trial ansatz, </span>
<span class="sd">        test ansatz, settings, static settings, and element number.</span>
<span class="sd">    ansatz_fun (callable): Function that constructs the ansatz (trial and test) functions.</span>
<span class="sd">    ref_int_coor (jnp.ndarray): Reference integration coordinates for the isoparametric element.</span>
<span class="sd">    ref_int_weights (jnp.ndarray): Reference integration weights for the isoparametric element.</span>
<span class="sd">    initial_config (bool, optional): If True, use the initial configuration for isoparametric mapping. Default is True.</span>

<span class="sd">  Returns:</span>
<span class="sd">    function</span>
<span class="sd">        A function that evaluates the residual and tangent matrix for the isoparametric element.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The returned function can be used to evaluate the residual and tangent matrix for the element.</span>
<span class="sd">    - The mode parameter in the returned function can be &#39;residual&#39; or &#39;tangent&#39;.</span>

<span class="sd">  The returned function has the following parameters:</span>
<span class="sd">    - fI (jnp.ndarray): Element nodal values.</span>
<span class="sd">    - xI (jnp.ndarray): Element nodal coordinates.</span>
<span class="sd">    - elem_number (int): Element number.</span>
<span class="sd">    - settings (dict): Settings for the computation.</span>
<span class="sd">    - static_settings (dict): Static settings for the computation.</span>
<span class="sd">    - mode (str): Specifies whether to compute the &#39;residual&#39; or &#39;tangent&#39;.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">user_element</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">elem_number</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">n_dofs</span> <span class="o">=</span> <span class="n">fI</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">xI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># One Gau point contribution</span>
    <span class="k">def</span> <span class="nf">residual_and_tangent</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">w_int</span><span class="p">):</span>

      <span class="k">def</span> <span class="nf">integrated_weak_form</span><span class="p">(</span><span class="n">test_fI</span><span class="p">,</span> <span class="n">trial_fI</span><span class="p">):</span>
        <span class="c1"># Define trial and test function ansatz</span>
        <span class="n">trial_ansatz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">trial_fI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="n">test_ansatz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">test_fI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>

        <span class="c1"># Evaluate weak form</span>
        <span class="n">discrete_weak_form</span> <span class="o">=</span> <span class="n">weak_form_fun</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">trial_ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">elem_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>

        <span class="c1"># Use ansatz for isoparametric mapping and compute determinant of Jacobian</span>
        <span class="k">if</span> <span class="n">initial_config</span><span class="p">:</span>
          <span class="n">mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Take first n_dim fields as displacements</span>
          <span class="n">uI</span> <span class="o">=</span> <span class="n">fI</span><span class="p">[:,</span> <span class="p">:</span><span class="n">xI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
          <span class="n">mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span> <span class="o">+</span> <span class="n">uI</span><span class="p">,</span> <span class="n">xI</span> <span class="o">+</span> <span class="n">uI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">overwrite_diff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">mapping</span><span class="p">)(</span><span class="n">x_int</span><span class="p">)</span>
        <span class="n">det_jacobian</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">jacobian</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">w_int</span> <span class="o">*</span> <span class="n">det_jacobian</span> <span class="o">*</span> <span class="n">discrete_weak_form</span>

      <span class="c1"># Residual</span>
      <span class="n">residual_fun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">integrated_weak_form</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">residual</span> <span class="o">=</span> <span class="n">residual_fun</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">fI</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

      <span class="c1"># Tangent</span>
      <span class="n">tangent_fun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">residual_fun</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">tangent</span> <span class="o">=</span> <span class="n">tangent_fun</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">fI</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dofs</span><span class="p">,</span><span class="n">n_dofs</span><span class="p">)</span>

      <span class="k">return</span> <span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">tangent</span><span class="p">)</span>

    <span class="c1"># Sum over Gau points</span>
    <span class="p">(</span><span class="n">residual_contrib</span><span class="p">,</span> <span class="n">tangent_contrib</span><span class="p">)</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">residual_and_tangent</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span><span class="n">ref_int_coor</span><span class="p">,</span> <span class="n">ref_int_weights</span><span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">residual_contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tangent</span> <span class="o">=</span> <span class="n">tangent_contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;residual&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">residual</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span><span class="s1">&#39;tangent&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">tangent</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;User elem mode has to be </span><span class="se">\&#39;</span><span class="s1">residual</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">tangent</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>

  <span class="k">return</span> <span class="n">user_element</span></div>


<div class="viewcode-block" id="isoparametric_surface_element_galerkin">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.isoparametric_surface_element_galerkin.html#autopdex.models.isoparametric_surface_element_galerkin">[docs]</a>
<span class="k">def</span> <span class="nf">isoparametric_surface_element_galerkin</span><span class="p">(</span><span class="n">weak_form_fun</span><span class="p">,</span> <span class="n">ansatz_fun</span><span class="p">,</span> <span class="n">ref_int_coor</span><span class="p">,</span> <span class="n">ref_int_weights</span><span class="p">,</span> <span class="n">tangent_contributions</span><span class="p">,</span> <span class="n">initial_config</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs an isoparametric surface element for Galerkin methods using a given weak form function.</span>

<span class="sd">  This function returns a user element function that evaluates the residual and tangent matrix for an isoparametric </span>
<span class="sd">  surface element based on the provided weak form and ansatz functions. The function can, for example, be used in </span>
<span class="sd">  combination with the weak_form_fun neumann_weak.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    weak_form_fun (callable): Function that evaluates the weak form given the integration point, trial ansatz, </span>
<span class="sd">        test ansatz, settings, static settings, and element number.</span>
<span class="sd">    ansatz_fun (callable): Function that constructs the ansatz (trial and test) functions.</span>
<span class="sd">    ref_int_coor (jnp.ndarray): Reference integration coordinates for the isoparametric element.</span>
<span class="sd">    ref_int_weights (jnp.ndarray): Reference integration weights for the isoparametric element.</span>
<span class="sd">    tangent_contributions (bool): If True, compute the tangent contributions; otherwise, return zero tangent.</span>
<span class="sd">    initial_config (bool, optional): If True, use the initial configuration for isoparametric mapping. Default is True.</span>

<span class="sd">  Returns:</span>
<span class="sd">    callable:</span>
<span class="sd">      A function that evaluates the residual and tangent matrix for the isoparametric surface element.</span>

<span class="sd">  Notes:</span>
<span class="sd">    - Currently, the weak form function must not contain derivatives wrt. the primary fields.</span>
<span class="sd">    - The returned function can be used to evaluate the residual and tangent matrix for the element.</span>
<span class="sd">    - The mode parameter in the returned function can be &#39;residual&#39; or &#39;tangent&#39;.</span>

<span class="sd">  The returned function has the following parameters:</span>
<span class="sd">    - fI (jnp.ndarray): Element nodal values.</span>
<span class="sd">    - xI (jnp.ndarray): Element nodal coordinates.</span>
<span class="sd">    - elem_number (int): Element number.</span>
<span class="sd">    - settings (dict): Settings for the computation.</span>
<span class="sd">    - static_settings (dict): Static settings for the computation.</span>
<span class="sd">    - mode (str): Specifies whether to compute the &#39;residual&#39; or &#39;tangent&#39;.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">user_element</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">elem_number</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="n">n_dofs</span> <span class="o">=</span> <span class="n">fI</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_dim</span> <span class="o">=</span> <span class="n">xI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># One Gau point contribution</span>
    <span class="k">def</span> <span class="nf">residual_and_tangent</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">w_int</span><span class="p">):</span>

      <span class="k">def</span> <span class="nf">integrated_weak_form</span><span class="p">(</span><span class="n">test_fI</span><span class="p">,</span> <span class="n">trial_fI</span><span class="p">):</span>
        <span class="c1"># Define trial and test function ansatz</span>
        <span class="n">trial_ansatz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">trial_fI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">test_ansatz</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">test_fI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Evaluate weak form</span>
        <span class="n">discrete_weak_form</span> <span class="o">=</span> <span class="n">weak_form_fun</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">trial_ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">elem_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>

        <span class="c1"># Compute the Jacobian</span>
        <span class="k">if</span> <span class="n">initial_config</span><span class="p">:</span>
          <span class="n">mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">xI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Take first n_dim fields as displacements</span>
          <span class="n">uI</span> <span class="o">=</span> <span class="n">fI</span><span class="p">[:,</span> <span class="p">:</span><span class="n">xI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
          <span class="n">mapping</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ansatz_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xI</span> <span class="o">+</span> <span class="n">uI</span><span class="p">,</span> <span class="n">xI</span> <span class="o">+</span> <span class="n">uI</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">overwrite_diff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">mapping</span><span class="p">)(</span><span class="n">x_int</span><span class="p">)</span>

        <span class="k">match</span> <span class="n">n_dim</span><span class="p">:</span>
          <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">G_1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">jacobian</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])])</span>
            <span class="n">E_3</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">G_1</span><span class="p">,</span> <span class="n">E_3</span><span class="p">))</span>
          <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">G_1</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">G_2</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">G_1</span><span class="p">,</span> <span class="n">G_2</span><span class="p">))</span>
          <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Surface element supports currently only lines in 2d and 2d-surfaces in 3d.&quot;</span>

        <span class="k">return</span> <span class="n">w_int</span> <span class="o">*</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">discrete_weak_form</span>

      <span class="c1"># Residual</span>
      <span class="n">residual_fun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="n">integrated_weak_form</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">residual</span> <span class="o">=</span> <span class="n">residual_fun</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">fI</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

      <span class="c1"># Tangent</span>
      <span class="k">if</span> <span class="n">tangent_contributions</span><span class="p">:</span>
        <span class="n">tangent_fun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">residual_fun</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="n">tangent_fun</span><span class="p">(</span><span class="n">fI</span><span class="p">,</span> <span class="n">fI</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_dofs</span><span class="p">,</span><span class="n">n_dofs</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dofs</span><span class="p">,</span> <span class="n">n_dofs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

      <span class="k">return</span> <span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">tangent</span><span class="p">)</span>

    <span class="c1"># Sum over Gau points</span>
    <span class="p">(</span><span class="n">residual_contrib</span><span class="p">,</span> <span class="n">tangent_contrib</span><span class="p">)</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">residual_and_tangent</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span><span class="n">ref_int_coor</span><span class="p">,</span> <span class="n">ref_int_weights</span><span class="p">)</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">residual_contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tangent</span> <span class="o">=</span> <span class="n">tangent_contrib</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;residual&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">residual</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span><span class="s1">&#39;tangent&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">tangent</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;User elem mode has to be </span><span class="se">\&#39;</span><span class="s1">residual</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">tangent</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>

  <span class="k">return</span> <span class="n">user_element</span></div>



<span class="c1">### Time integration procedures</span>
<div class="viewcode-block" id="forward_backward_euler_weak">
<a class="viewcode-back" href="../../_autosummary/autopdex.models.forward_backward_euler_weak.html#autopdex.models.forward_backward_euler_weak">[docs]</a>
<span class="k">def</span> <span class="nf">forward_backward_euler_weak</span><span class="p">(</span><span class="n">inertia_coeff_fun</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs a weak form time discretization function using the Forward or Backward Euler method.</span>

<span class="sd">  For an examplary use, see the examples with explicit and implicit time integration.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    inertia_coeff_fun (callable): Function to compute the inertia coefficient given spatial coordinates and settings.</span>

<span class="sd">  Returns:</span>
<span class="sd">    callable:</span>
<span class="sd">      A function that evaluates the weak form time discretization for the PDE.</span>

<span class="sd">  The returned function has the following parameters:</span>
<span class="sd">    - x (jnp.ndarray): Spatial coordinates at the integration point.</span>
<span class="sd">    - ansatz (callable): Ansatz function representing the primary field at time step n+1.</span>
<span class="sd">    - test_ansatz (callable): Test ansatz function representing the test function.</span>
<span class="sd">    - settings (dict): Settings for the computation, including:</span>
<span class="sd">      - &#39;dofs n&#39;: Degrees of freedom at the previous time step.</span>
<span class="sd">      - &#39;connectivity&#39;: Connectivity information for the elements.</span>
<span class="sd">      - &#39;time increment&#39;: Time increment delta_t.</span>
<span class="sd">    - static_settings (dict): Static settings for the computation.</span>
<span class="sd">    - int_point_number (int): Integration point number.</span>
<span class="sd">    - set: Number of domain</span>

<span class="sd">  Notes:</span>
<span class="sd">    - The primary field is evaluated at both time steps n and n+1.</span>
<span class="sd">    - The time derivative is computed using the Forward or Backward Euler method, depending on the use case.</span>
<span class="sd">    - The inertia coefficient is used to scale the time derivative term.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">time_discretization_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
    <span class="c1"># Test function</span>
    <span class="n">test_function</span> <span class="o">=</span> <span class="n">test_ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Primary field evaluated at n and n+1</span>
    <span class="n">dofs_n</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dofs n&#39;</span><span class="p">]</span>
    <span class="n">neighbor_list</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">static_settings</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">][</span><span class="nb">set</span><span class="p">])[</span><span class="n">int_point_number</span><span class="p">]</span>
    <span class="n">local_dofs_n</span> <span class="o">=</span> <span class="n">dofs_n</span><span class="p">[</span><span class="n">neighbor_list</span><span class="p">]</span>
    <span class="n">ansatz_n</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">solution_structures</span><span class="o">.</span><span class="n">solution_structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="n">local_dofs_n</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>
    <span class="n">field_n</span> <span class="o">=</span> <span class="n">ansatz_n</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Forward/Backward Euler</span>
    <span class="n">delta_t</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;time increment&#39;</span><span class="p">]</span>
    <span class="n">time_derivative</span> <span class="o">=</span> <span class="p">(</span><span class="n">field</span> <span class="o">-</span> <span class="n">field_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta_t</span>

    <span class="c1"># E.g. heat capacity or whatever is multiplied with first order time derivative</span>
    <span class="n">inertia_coeff</span> <span class="o">=</span> <span class="n">inertia_coeff_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span> <span class="n">inertia_coeff</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">test_function</span><span class="p">,</span> <span class="n">time_derivative</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">time_discretization_fun</span></div>


<span class="k">def</span> <span class="nf">central_differences</span><span class="p">(</span><span class="n">density_fun</span><span class="p">,</span> <span class="n">damping</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Constructs weak form contributions for acceleration (and optional damping) term based on central differences.</span>

<span class="sd">  Parameters:</span>
<span class="sd">    density_fun (callable): Function to compute the density coefficient given spatial coordinates and settings.</span>
<span class="sd">    damping (bool): Whether to turn on damping. Damping requires settings[&#39;damping coefficient&#39;] to be set.</span>

<span class="sd">  Returns:</span>
<span class="sd">    callable:</span>
<span class="sd">      A function that evaluates the weak form contributions.</span>

<span class="sd">  The returned function has the following parameters:</span>
<span class="sd">    - x (jnp.ndarray): Spatial coordinates at the integration point.</span>
<span class="sd">    - ansatz (callable): Ansatz function representing the primary field at time step n+1.</span>
<span class="sd">    - test_ansatz (callable): Test ansatz function representing the test function.</span>
<span class="sd">    - settings (dict): Settings for the computation, including:</span>
<span class="sd">      - &#39;dofs n&#39;: Degrees of freedom at the previous time step.</span>
<span class="sd">      - &#39;connectivity&#39;: Connectivity information for the elements.</span>
<span class="sd">      - &#39;time increment&#39;: Time increment delta_t.</span>
<span class="sd">    - static_settings (dict): Static settings for the computation.</span>
<span class="sd">    - int_point_number (int): Integration point number.</span>
<span class="sd">    - set: Number of domain</span>

<span class="sd">  Notes:</span>
<span class="sd">    - Requires settings[&#39;dofs n], settings[&#39;dofs n-1&#39;] and settings[&#39;time increment&#39;].</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">weak_form_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">,</span> <span class="n">test_ansatz</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>

    <span class="c1"># Test function</span>
    <span class="n">test_function</span> <span class="o">=</span> <span class="n">test_ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Primary field evaluated at n-1, n and n+1</span>
    <span class="n">dofs_n</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dofs n&#39;</span><span class="p">]</span>
    <span class="n">dofs_n_min_1</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;dofs n-1&#39;</span><span class="p">]</span>
    <span class="n">neighbor_list</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">static_settings</span><span class="p">[</span><span class="s1">&#39;connectivity&#39;</span><span class="p">][</span><span class="nb">set</span><span class="p">])[</span><span class="n">int_point_number</span><span class="p">]</span>
    <span class="n">ansatz_n</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">solution_structures</span><span class="o">.</span><span class="n">solution_structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="n">dofs_n</span><span class="p">[</span><span class="n">neighbor_list</span><span class="p">],</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>
    <span class="n">ansatz_n_min_1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">solution_structures</span><span class="o">.</span><span class="n">solution_structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">int_point_number</span><span class="p">,</span> <span class="n">dofs_n_min_1</span><span class="p">[</span><span class="n">neighbor_list</span><span class="p">],</span> <span class="n">settings</span><span class="p">,</span> <span class="n">static_settings</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>
    <span class="n">u_n</span> <span class="o">=</span> <span class="n">ansatz_n</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">u_n_min_1</span> <span class="o">=</span> <span class="n">ansatz_n_min_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">u_n_plus_1</span> <span class="o">=</span> <span class="n">ansatz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


    <span class="c1"># Central differences</span>
    <span class="n">delta_t</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;time increment&#39;</span><span class="p">]</span>
    <span class="n">a_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_n_plus_1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u_n</span> <span class="o">-</span> <span class="n">u_n_min_1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">delta_t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">v_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_n_plus_1</span> <span class="o">-</span> <span class="n">u_n_min_1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)</span>

    <span class="c1"># E.g. heat capacity or whatever is multiplied with first order time derivative</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">density_fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">damping</span><span class="p">:</span>
      <span class="n">damping_coeff</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;damping coefficient&#39;</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">density</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">test_function</span><span class="p">,</span> <span class="n">a_n</span> <span class="o">+</span> <span class="n">damping_coeff</span> <span class="o">*</span> <span class="n">v_n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">density</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">test_function</span><span class="p">,</span> <span class="n">a_n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">weak_form_fun</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Tobias Bode.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>